package cli

import (
	"fmt"

	enrichDocs "github.com/jfrog/jfrog-cli-security/cli/docs/enrich"
	"github.com/jfrog/jfrog-cli-security/commands/enrich"

	"github.com/jfrog/jfrog-cli-core/v2/utils/usage"

	"github.com/jfrog/jfrog-cli-core/v2/common/cliutils"
	commandsCommon "github.com/jfrog/jfrog-cli-core/v2/common/commands"
	outputFormat "github.com/jfrog/jfrog-cli-core/v2/common/format"
	"github.com/jfrog/jfrog-cli-core/v2/common/progressbar"
	pluginsCommon "github.com/jfrog/jfrog-cli-core/v2/plugins/common"
	"github.com/jfrog/jfrog-cli-core/v2/plugins/components"
	coreConfig "github.com/jfrog/jfrog-cli-core/v2/utils/config"
	"github.com/jfrog/jfrog-cli-core/v2/utils/coreutils"
	"github.com/jfrog/jfrog-client-go/utils/log"

	auditSpecificDocs "github.com/jfrog/jfrog-cli-security/cli/docs/auditspecific"
	auditDocs "github.com/jfrog/jfrog-cli-security/cli/docs/scan/audit"
	buildScanDocs "github.com/jfrog/jfrog-cli-security/cli/docs/scan/buildscan"
	curationDocs "github.com/jfrog/jfrog-cli-security/cli/docs/scan/curation"
	dockerScanDocs "github.com/jfrog/jfrog-cli-security/cli/docs/scan/dockerscan"
	scanDocs "github.com/jfrog/jfrog-cli-security/cli/docs/scan/scan"
	"github.com/jfrog/jfrog-cli-security/cli/flags"

	"github.com/jfrog/jfrog-cli-security/commands/audit"
	"github.com/jfrog/jfrog-cli-security/commands/curation"
	"github.com/jfrog/jfrog-cli-security/commands/scan"
	"github.com/jfrog/jfrog-cli-security/utils/techutils"
	"github.com/jfrog/jfrog-cli-security/utils/xsc"
)

const dockerScanCmdHiddenName = "dockerscan"

func getAuditAndScansCommands() []components.Command {
	return []components.Command{
		{
			Name:        "scan",
			Aliases:     []string{"s"},
			Flags:       flags.GetCommandFlags(flags.XrScan),
			Description: scanDocs.GetDescription(),
			Arguments:   scanDocs.GetArguments(),
			Category:    securityCategory,
			Action:      ScanCmd,
		},
		{
			Name:        "sbom-enrich",
			Aliases:     []string{"se"},
			Flags:       flags.GetCommandFlags(flags.Enrich),
			Description: enrichDocs.GetDescription(),
			Arguments:   enrichDocs.GetArguments(),
			Category:    securityCategory,
			Action:      EnrichCmd,
		},
		{
			Name:        "build-scan",
			Aliases:     []string{"bs"},
			Flags:       flags.GetCommandFlags(flags.BuildScan),
			Description: buildScanDocs.GetDescription(),
			Arguments:   buildScanDocs.GetArguments(),
			Category:    securityCategory,
			Action:      BuildScan,
		},
		{
			// this command is hidden and have no logic, it will be run to provide 'help' as a part of the buildtools CLI for 'docker' commands. ('jf docker scan')
			// CLI buildtools will run the command if requested: https://github.com/jfrog/jfrog-cli/blob/v2/buildtools/cli.go
			Name:        dockerScanCmdHiddenName,
			Flags:       flags.GetCommandFlags(flags.DockerScan),
			Description: dockerScanDocs.GetDescription(),
			Arguments:   dockerScanDocs.GetArguments(),
			UsageOptions: &components.UsageOptions{
				Usage:                     dockerScanDocs.Usage,
				ReplaceAutoGeneratedUsage: true,
			},
			Hidden: true,
		},
		{
			Name:        "audit",
			Aliases:     []string{"aud"},
			Flags:       flags.GetCommandFlags(flags.Audit),
			Description: auditDocs.GetDescription(),
			Category:    securityCategory,
			Action:      AuditCmd,
		},
		{
			Name:        "curation-audit",
			Aliases:     []string{"ca"},
			Flags:       flags.GetCommandFlags(flags.CurationAudit),
			Description: curationDocs.GetDescription(),
			Category:    securityCategory,
			Action:      CurationCmd,
		},

		// TODO: Deprecated commands (remove at next CLI major version)
		{
			Name:        "audit-mvn",
			Aliases:     []string{"am"},
			Flags:       flags.GetCommandFlags(flags.AuditMvn),
			Description: auditSpecificDocs.GetMvnDescription(),
			Action: func(c *components.Context) error {
				return AuditSpecificCmd(c, techutils.Maven)
			},
			Hidden: true,
		},
		{
			Name:        "audit-gradle",
			Aliases:     []string{"ag"},
			Flags:       flags.GetCommandFlags(flags.AuditGradle),
			Description: auditSpecificDocs.GetGradleDescription(),
			Action: func(c *components.Context) error {
				return AuditSpecificCmd(c, techutils.Gradle)
			},
			Hidden: true,
		},
		{
			Name:        "audit-npm",
			Aliases:     []string{"an"},
			Flags:       flags.GetCommandFlags(flags.AuditNpm),
			Description: auditSpecificDocs.GetNpmDescription(),
			Action: func(c *components.Context) error {
				return AuditSpecificCmd(c, techutils.Npm)
			},
			Hidden: true,
		},
		{
			Name:        "audit-go",
			Aliases:     []string{"ago"},
			Flags:       flags.GetCommandFlags(flags.AuditGo),
			Description: auditSpecificDocs.GetGoDescription(),
			Action: func(c *components.Context) error {
				return AuditSpecificCmd(c, techutils.Go)
			},
			Hidden: true,
		},
		{
			Name:        "audit-pip",
			Aliases:     []string{"ap"},
			Flags:       flags.GetCommandFlags(flags.AuditPip),
			Description: auditSpecificDocs.GetPipDescription(),
			Action: func(c *components.Context) error {
				return AuditSpecificCmd(c, techutils.Pip)
			},
			Hidden: true,
		},
		{
			Name:        "audit-pipenv",
			Aliases:     []string{"ape"},
			Flags:       flags.GetCommandFlags(flags.AuditPipenv),
			Description: auditSpecificDocs.GetPipenvDescription(),
			Action: func(c *components.Context) error {
				return AuditSpecificCmd(c, techutils.Pipenv)
			},
			Hidden: true,
		},
	}
}

func EnrichCmd(c *components.Context) error {
	// Validate
	if len(c.Arguments) == 0 {
		return pluginsCommon.PrintHelpAndReturnError("providing a file path argument is mandatory", c)
	}
	enrichCmd := enrich.NewEnrichCommand()
	// Platform connection
	serverDetails, err := flags.ParsePlatformConnectionFlags(c)
	if err != nil {
		return err
	}
	enrichCmd.SetServerDetails(serverDetails)
	// Target configuration
	specFile, err := flags.ParseSpecFileScanFlags(c)
	if err != nil {
		return err
	}
	enrichCmd.SetSpec(specFile)
	// Parse specific flags
	threads, err := pluginsCommon.GetThreadsCount(c)
	if err != nil {
		return err
	}
	enrichCmd.SetThreads(threads)
	// Run the command
	return commandsCommon.Exec(enrichCmd)
}

func ScanCmd(c *components.Context) error {
	// Validate
	if len(c.Arguments) == 0 && !c.IsFlagSet(flags.SpecFlag) {
		return pluginsCommon.PrintHelpAndReturnError("providing either a <source pattern> argument or the 'spec' option is mandatory", c)
	}
	scanCmd := scan.NewScanCommand()
	// Platform connection
	serverDetails, err := flags.ParsePlatformConnectionFlags(c)
	if err != nil {
		return err
	}
	scanCmd.SetServerDetails(serverDetails)
	// Target configuration
	specFile, err := flags.ParseSpecFileScanFlags(c)
	if err != nil {
		return err
	}
	scanCmd.SetSpec(specFile)
	// Violation context configuration
	watches, projectKey, _, failOvViolation, err := flags.ParseViolationContext(c)
	if err != nil {
		return err
	}
	scanCmd.SetIncludeVulnerabilities(flags.IsViolationContextProvided(c)).SetFail(failOvViolation).SetWatches(watches).SetProject(projectKey)
	// Output configuration
	format, extendedTable, includeLicenses, err := flags.ParseOutputDisplayFlags(c)
	if err != nil {
		return err
	}
	scanCmd.SetOutputFormat(format).SetPrintExtendedTable(extendedTable).SetIncludeLicenses(includeLicenses)
	// Filter content configuration
	minSeverity, fixableOnly, err := flags.ParseFilterContentFlags(c)
	if err != nil {
		return err
	}
	scanCmd.SetMinSeverityFilter(minSeverity).SetFixableOnly(fixableOnly)
	// Parse specific flags
	threads, err := pluginsCommon.GetThreadsCount(c)
	if err != nil {
		return err
	}
	scanCmd.SetThreads(threads).SetBypassArchiveLimits(c.GetBoolFlagValue(flags.BypassArchiveLimits))
	// Run the command
	return commandsCommon.Exec(scanCmd)
}

// Since indirect command is not registered normally, we need to handle printing 'help' here by ourselves.
func validateIndirectCommand(c *components.Context, cmdName string) (helpRequested bool, err error) {
	c.CommandName = cmdName
	return cliutils.ShowGenericCmdHelpIfNeeded(c.Arguments, pluginsCommon.GetPrintCurrentCmdHelp(c))
}

func DockerScan(c *components.Context, image string) error {
	// Validate
	if helpRequested, err := validateIndirectCommand(c, dockerScanCmdHiddenName); helpRequested || err != nil {
		return err
	}
	// Target configuration
	if image == "" {
		return pluginsCommon.GetPrintCurrentCmdHelp(c)()
	}
	containerScanCommand := scan.NewDockerScanCommand().SetImageTag(image)
	// Platform connection
	serverDetails, err := flags.ParsePlatformConnectionFlags(c)
	if err != nil {
		return err
	}
	containerScanCommand.SetServerDetails(serverDetails)
	// Violation context configuration
	watches, projectKey, targetRepo, failOvViolation, err := flags.ParseViolationContext(c)
	if err != nil {
		return err
	}
	containerScanCommand.SetTargetRepoPath(targetRepo).
		SetWatches(watches).
		SetProject(projectKey).
		SetFail(failOvViolation).
		SetIncludeVulnerabilities(flags.IsViolationContextProvided(c))
	// Output configuration
	format, extendedTable, includeLicenses, err := flags.ParseOutputDisplayFlags(c)
	if err != nil {
		return err
	}
	containerScanCommand.SetOutputFormat(format).SetPrintExtendedTable(extendedTable).SetIncludeLicenses(includeLicenses)
	// Filter content configuration
	minSeverity, fixableOnly, err := flags.ParseFilterContentFlags(c)
	if err != nil {
		return err
	}
	containerScanCommand.SetMinSeverityFilter(minSeverity).SetFixableOnly(fixableOnly)
	// Parse specific flags
	threads, err := pluginsCommon.GetThreadsCount(c)
	if err != nil {
		return err
	}
	containerScanCommand.SetThreads(threads).SetBypassArchiveLimits(c.GetBoolFlagValue(flags.BypassArchiveLimits))
	// Run the command
	return progressbar.ExecWithProgress(containerScanCommand)
}

// Scan published builds with Xray
func BuildScan(c *components.Context) error {
	// Validate
	if len(c.Arguments) > 2 {
		return pluginsCommon.WrongNumberOfArgumentsHandler(c)
	}
	// Target configuration
	buildConfiguration := pluginsCommon.CreateBuildConfiguration(c)
	if err := buildConfiguration.ValidateBuildParams(); err != nil {
		return err
	}
	buildScanCmd := scan.NewBuildScanCommand().SetBuildConfiguration(buildConfiguration)
	// Platform connection
	serverDetails, err := flags.ParsePlatformConnectionFlags(c)
	if err != nil {
		return err
	}
	buildScanCmd.SetServerDetails(serverDetails)
	// Output configuration
	format, extendedTable, _, err := flags.ParseOutputDisplayFlags(c)
	if err != nil {
		return err
	}
	buildScanCmd.SetOutputFormat(format).SetPrintExtendedTable(extendedTable)
	// Violation context configuration
	if flags.IsViolationContextProvided(c) && format != outputFormat.Sarif {
		// Sarif shouldn't include the additional all-vulnerabilities info that received by adding the vuln flag
		buildScanCmd.SetIncludeVulnerabilities(c.GetBoolFlagValue(flags.Vuln))
	}
	buildScanCmd.SetFailBuild(c.GetBoolFlagValue(flags.Fail))
	// Specific flags
	buildScanCmd.SetRescan(c.GetBoolFlagValue(flags.Rescan))
	// Run the command
	return commandsCommon.Exec(buildScanCmd)
}

func CurationCmd(c *components.Context) error {
	curationAuditCommand := curation.NewCurationAuditCommand()
	// Platform connection
	serverDetails, err := pluginsCommon.CreateServerDetailsWithConfigOffer(c, true, cliutils.Rt)
	if err != nil {
		return err
	}
	curationAuditCommand.SetServerDetails(serverDetails).SetInsecureTls(c.GetBoolFlagValue(flags.InsecureTls))
	// Target configuration
	requestedWorkingDirs, _ := flags.ParseSourceCodeTargetFlags(c)
	curationAuditCommand.SetWorkingDirs(requestedWorkingDirs)
	// Output configuration
	format, err := curation.GetCurationOutputFormat(c.GetStringFlagValue(flags.OutputFormat))
	if err != nil {
		return err
	}
	curationAuditCommand.SetOutputFormat(format)
	// Specific flags
	threads, err := pluginsCommon.GetThreadsCount(c)
	if err != nil {
		return err
	}
	curationAuditCommand.SetParallelRequests(threads).SetIsCurationCmd(true)
	curationAuditCommand.SetExcludeTestDependencies(c.GetBoolFlagValue(flags.ExcludeTestDeps)).
		SetUseWrapper(c.GetBoolFlagValue(flags.UseWrapper)).
		SetNpmScope(c.GetStringFlagValue(flags.DepType)).
		SetPipRequirementsFile(c.GetStringFlagValue(flags.RequirementsFile))
	// Run the command
	return progressbar.ExecWithProgress(curationAuditCommand)
}

func CreateAuditCmd(c *components.Context) (*audit.AuditCommand, error) {
	auditCmd := audit.NewGenericAuditCommand()
	// Platform connection
	serverDetails, err := flags.ParsePlatformConnectionFlags(c)
	if err != nil {
		return nil, err
	}
	auditCmd.SetServerDetails(serverDetails).SetInsecureTls(c.GetBoolFlagValue(flags.InsecureTls))
	// Target configuration
	requestedWorkingDirs, pathExclusions := flags.ParseSourceCodeTargetFlags(c)
	auditCmd.SetWorkingDirs(requestedWorkingDirs).SetExclusions(pathExclusions)
	// Violation context configuration
	watches, projectKey, targetRepo, failOvViolation, err := flags.ParseViolationContext(c)
	if err != nil {
		return nil, err
	}
	auditCmd.SetIncludeVulnerabilities(flags.IsViolationContextProvided(c)).SetTargetRepoPath(targetRepo).SetWatches(watches).SetProject(projectKey).SetFail(failOvViolation)
	// Output configuration
	format, extendedTable, includeLicenses, err := flags.ParseOutputDisplayFlags(c)
	if err != nil {
		return nil, err
	}
	auditCmd.SetPrintExtendedTable(extendedTable).SetIncludeLicenses(includeLicenses).SetOutputFormat(format)
	// Filter content configuration
	minSeverity, fixableOnly, err := flags.ParseFilterContentFlags(c)
	if err != nil {
		return nil, err
	}
	auditCmd.SetMinSeverityFilter(minSeverity).SetFixableOnly(fixableOnly)
	// Parse requested specific sub scans
	requestedSubScans, err := flags.ParseRequestedScanTypesFlags(c)
	if err != nil {
		return nil, err
	}
	if len(requestedSubScans) > 0 {
		auditCmd.SetScansToPerform(requestedSubScans)
	}
	// Parse specific flags
	threads, err := pluginsCommon.GetThreadsCount(c)
	if err != nil {
		return nil, err
	}
	auditCmd.SetThreads(threads).SetThirdPartyApplicabilityScan(c.GetBoolFlagValue(flags.ThirdPartyContextualAnalysis)).SetUseJas(true)
	// Parse specific technology configuration flags
	auditCmd.SetUseWrapper(c.GetBoolFlagValue(flags.UseWrapper)).
		SetNpmScope(c.GetStringFlagValue(flags.DepType)).
		SetExcludeTestDependencies(c.GetBoolFlagValue(flags.ExcludeTestDeps)).
		SetPipRequirementsFile(c.GetStringFlagValue(flags.RequirementsFile))
	// Xsc service
	auditCmd.SetAnalyticsMetricsService(xsc.NewAnalyticsMetricsService(serverDetails))
	return auditCmd, err
}

func AuditCmd(c *components.Context) error {
	auditCmd, err := CreateAuditCmd(c)
	if err != nil {
		return err
	}
	// Parse Technologies flags
	auditCmd.SetTechnologies(flags.ParseRequestedTechnologiesFlags(c))
	// Run the command
	err = progressbar.ExecWithProgress(auditCmd)
	// Reporting error if Xsc service is enabled
	reportErrorIfExists(err, auditCmd)
	return err
}

func AuditSpecificCmd(c *components.Context, technology techutils.Technology) error {
	logNonGenericAuditCommandDeprecation(c.CommandName)
	auditCmd, err := CreateAuditCmd(c)
	if err != nil {
		return err
	}
	// Parse Technologies flags
	auditCmd.SetTechnologies([]string{string(technology)})
	// Run the command
	err = progressbar.ExecWithProgress(auditCmd)
	// Reporting error if Xsc service is enabled
	reportErrorIfExists(err, auditCmd)
	return err
}

func logNonGenericAuditCommandDeprecation(cmdName string) {
	if cliutils.ShouldLogWarning() {
		log.Warn(
			`You are using a deprecated syntax of the command.
	Instead of:
	$ ` + coreutils.GetCliExecutableName() + ` ` + cmdName + ` ...
	Use:
	$ ` + coreutils.GetCliExecutableName() + ` audit ...`)
	}
}

func reportErrorIfExists(err error, auditCmd *audit.AuditCommand) {
	if err == nil || !usage.ShouldReportUsage() {
		return
	}
	var serverDetails *coreConfig.ServerDetails
	serverDetails, innerError := auditCmd.ServerDetails()
	if innerError != nil {
		log.Debug(fmt.Sprintf("failed to get server details for error report: %q", innerError))
		return
	}
	if reportError := xsc.ReportError(serverDetails, err, "cli"); reportError != nil {
		log.Debug("failed to report error log:" + reportError.Error())
	}
}
